#!/bin/bash
#
# Default configuration file.
#
# DO NOT EDIT THIS FILE. Edit "myceal.sh" file for personal configuration.
# If there's no "myceal.sh" file, copy and change the content of this file.

temp=""
windows=""
gitbranch=""

title="Effective & Easy (Ewancoder) Arch Linux installation script"
version="2.5 User-centered, 2015"
release="2.5.0 User-centered"

#=== General ===

    # Install from within already running OS. Using hostinstall=1 you can
    # install Arch linux from any other distribution (like Debian), and even
    # (possibly) from BSD, MacOS, Windows, <any other> operating systems.
    #
    # This mode uses *chroot* to log into minimal root live cd ($iso),
    # installation then proceeds under this *chroot* inside another *chroot*.
    #
    # So basically, if you can get chroot working inside your OS, you should be
    # able to install Arch linux with this script right away.
    hostinstall=0

    # Path to Arch linux rootfs (minimal live-cd) *.fs.sfs image needed for
    # installation from within running OS ($hostinstall=1).
    iso="http://ftp.byfly.by/pub/archlinux/iso/$(date +%Y.%m.01)/arch/x86_64/airootfs.sfs"

    # Fully automatic install, pause only if error occurs. If $auto=0, the
    # script will pause before each step and ask you to confirm execution of
    # this step by pressing [RETURN].
    auto=0

    # Show each executed command and values of used variables.
    verbose=0

    # Substitute all variables with their values in verbose mode.
    #
    # If $substitute=0, verbose output shows variables like variables (e.g.
    # 'echo something > $filename').
    # If $substitute=1, verbose output shows variable values instead of
    # the variables itself (e.g. 'echo something > myfile').
    substitute=1

    # This value indicates how much seconds to wait until trying repeating
    # failed command automatically.
    # If value is 0, there's no timeout and script will wait forever or until
    # user intervenes.
    timeout=0

    # PC hostname. It will be discovered in local network.
    hostname=archpc

    # Local timezone. You can find list of time zones by issuing
    # `timedatectl list-timezones` command. Also, you can search for it in
    # /usr/share/zoneinfo folder.
    timezone=Europe/Minsk

    # All needed locales. System locale is the first one.
    locale=( en_US.UTF-8 )

    # Country names for repository mirror list arrangement.
    #
    # These names are patterns for default mirrorlist file. For example,
    # 'United' will match both 'United States' and 'United Kingdom'.
    mirror=( Belarus Denmark Russia United France )

#=== Network ===

    # Network setup.
    #
    # 0 - do not setup. This whole block is ignored.
    # 1 - setup netctl profile based on given configuration.
    # 2 - just enable dhcpcd service. This is simplest option if you have dhcp
    # server running on your router.
    network=0

    # Netctl profile (for network=1). Example profiles located in
    # /etc/netctl/examples directory
    profile=ethernet-static

    # Network interface to use. See `ip link` output for the list of available
    # interfaces.
    interface=$(ip link | grep -o 'en[ps].\{1,2\}[fs].\{1,2\}')

    # Static IP address configuration.
    ip=192.168.100.22
    dns=192.168.100.1

    # Wi-Fi access point credentials (used for netctl Wi-Fi profiles).
    essid=ESSID
    key=KEY

#=== Devices ===

    # Place devices in the order of mounting. So Root '/' should go before any
    # other partition.

    # Mounted partition description, text information to display during install.
    description=( Root )

    # Path to corresponding devices (e.g. /dev/sda1).
    device=( /dev/archlinux/root )

    # Mount points for devices, starting from '/'.
    mount=( / )

    # Filesystem.
    type=( ext4 )

    # Options for fstab file.
    # 'dump' is used for backup, and is usually 0.
    # 'pass' is used by fsck check tool, and is usually 1 for root partition
    # and 2 for other partitions.
    option=( rw,relatime )
    dump=( 0 )
    pass=( 1 )

    # Where to place Master Boot Record. This is usually first bootable device
    # (for example, /dev/sda).
    mbr=/dev/sdx

    # Copy fonts folder from Windows OS partition (C:\Windows\Fonts).
    # This variable should not be set if there's no Windows partition.
    #windows=/dev/sdx1

    # Temporary partition for extracting rootfs image when installing from
    # within another host system (hostinstall=1).
    #
    # Normally rootfs will extract into root '/' partition, but if you have no
    # free space left there, you can specify another temporary partition to use.
    #temp=/dev/sdx1

#=== Users ===

    # User login. Could be more than 1 using arrays: user=( user1 user2 ).
    # Main user is the first user.
    user=username

    # Default shell (per user).
    shell=/bin/bash

    # User groups. If you want to declare multiple groups for one user, use
    # quotes to divide per-user groups. Groups themselves divided by commas:
    # group=( 'user1group1,user1group2' 'user2group1,user2group2' )
    #
    # Also group 'users' is added to each user automatically.
    group=fuse

    # Scripts to execute as USER after install (additional commands).
    #userscript=user_script.sh

#=== Git dotfiles ===

    # Git dotfiles configuration.
    #
    # If you have git *dotfiles* repository with all configuration files from
    # your Arch linux OS, you can set up automatic configuration using *symlink*
    # method.

    # Path to github repository like 'github.com/<PATH>'.
    #gitrepo=( username/dotfiles )

    # Path in the filesystem where repository will be placed.
    #gitfolder=( /home/username/.dotfiles )
    
    # CHOWN rule to append to the whole repository. You need to set this for
    # user-specific dotfiles because all repositories are cloned and placed
    # by *root* user.
    #gitrule=( 'username:users' )

    # Git branch to checkout.
    #gitbranch=( 'master' )

    # Submodules to init.
    #gitmodule=( "some-submodule" )

    # Where to link git repository. Destination folder. All content from
    # repository will be linked to the root of *gitlink* folder.
    #gitlink=( /home/username )

#=== Restore backup ===

    # Restore backup [FROM] [TO]. List of folder pairs.
    # Backup is restored BEFORE git dotfiles repositories are cloned.
    #backup=(
    #    "/mnt/backup/Arch/ /home/username/"
    #)

    # Script to be executed as ROOT after install (additional commands).
    #rootscript=root_script.sh

#=== Software ===

    # Software groups description.
    #softtitle=(
    #    Drivers
    #    Editors
    #    Web
    #)

    # Software list.
    #software=(
    #    "driver-1 driver-2"
    #    "editor-1 editor-2"
    #    "webapp-1 webapp-2"
    #)

    # Services to enable.
    #service=( service-1 service-2 )

    # AUR packages to build.
    #build=( package-1 package-2 )

#=== INTERFACE ===
# Do NOT touch this section. It is only for output styling purposes.

# Color constants.
    Green=$(tput setaf 2)
    Yellow=$(tput setaf 3)
    Red=$(tput setaf 1)
    Blue=$(tput setaf 6)
    Bold=$(tput bold)
    Def=$(tput sgr0)

# Message function - neat output.
mess(){
    if [ -f /var/lib/pacman/db.lck ]; then
        # Need this in case pacman is still locked from last operation. This
        # happens when installing on SSD (very fast).
        sudo rm -f /var/lib/pacman/db.lck
    fi

    # Determine 'option' and 'message'.
    if [ "${#1}" -gt "2" ]; then
        o=$2
        m=$1
    else
        o=$1
        m=$2
    fi

    # Stylize message.
    case $o in
        "-p")
            Style="$Bold$Yellow\n-> $m [MANUAL]$Def"
            step=$m
            ;;
        "-w")
            Style="\n$Bold$Red! $m$Def"
            ;;
        "-t")
            Line="$(printf "%$(tput cols)s\n"|tr ' ' '-')"
            Style="\n$Line$Bold$Green\n-> $m$Def\n$Line"
            step=$m
            ;;
        "-q")
            Style="$Bold$Red$m$Def"
            ;;
        "-v")
            Style="$Blue-> $m$Def"
            echo "$m" | grep -oP '(?<!\[)\$[{(]?[^"\s\/\047.\\]+[})]?' | uniq > vars
            if [ ! "$(cat vars)" == "" ]; then
                while read -r p; do
                    value=$(eval echo "$p")
                    Style=$(echo -e "$Style\n\t$Green$p = $value$Def")
                done < vars
            fi
            rm vars
            ;;
        *)
            Style="$Bold$Green\n-> $Def$Bold$m$Def"
            step=$m
            ;;
    esac

    # Print message.
    if [ "$o" == "-v" ]; then
        echo -en "$Style\n"
    elif [ "$o" == "-p" ]; then
        echo -en "$Style"
        read -r
    else
        echo -e "$Style"
        if ([ "$o" == "-w" ] || [ "$o" == "-p" ]) ||
            ([ "$o" == "" ] && [ $auto -eq 0 ]); then
            read -rp "$Bold${Yellow}Continue [ENTER]$Def"
        fi
    fi
}

#=== Read user config ===
#if [ -f myceal.sh ]; then
#    source myceal.sh
#fi
